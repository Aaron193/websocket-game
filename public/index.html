<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      #leaderboard {
        background: black;
        color: white;
        position: fixed;
        right: 0px;
        width: 140px;
        top: 0px;
        height: 100vh;
        padding: 10px;
        font-size: 18px;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div id="leaderboard"></div>

    <script src="/socket.io/socket.io.js"></script>

    <script>
      const socket = io();
      const canvas = document.getElementById("canvas");
      const width = window.innerWidth;
      const height = window.innerHeight;
      const leaderboardEl = document.getElementById("leaderboard");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      let lastRender = 0;
      ctx.fillStyle = "red";

      const coinAudio = new Audio("coin.mp3");
      coinAudio.volume = 0.3;

      const TILE_SIZE = 128;
      const COIN_SIZE = 6;
      const INTERPOLATION_SPEED = 0.05;
      const PLAYER_SIZE = 16;

      let map = [[]];
      let gameMap = {};
      let players = [];
      let coins = [];
      const interpolations = {};

      const drawLeaderboard = () => {
        leaderboardEl.innerHTML = "Scores!";
        const sortedScores = [...players].sort((p1, p2) => p2.score - p1.score);
        for (const player of sortedScores) {
          const scoreEl = document.createElement("div");
          scoreEl.innerText = `${player.name}: ${player.score}`;
          leaderboardEl.append(scoreEl);
        }
      };

      setInterval(drawLeaderboard, 2000);
      drawLeaderboard();

      const controls = {
        up: false,
        down: false,
        left: false,
        right: false,
        jump: false,
      };

      const keyMap = {
        w: "up",
        s: "down",
        a: "left",
        d: "right",
        " ": "jump",
      };

      const mapImage = new Image();

      socket.on("map", ({ map: serverMap, gameMap: serverGameMap }) => {
        map = serverMap;
        gameMap = serverGameMap;
        mapImage.src = gameMap.tileset.image;
      });

      socket.on("players", (serverPlayers) => {
        players = serverPlayers;
        for (const player of players) {
          if (!interpolations[player.id]) {
            interpolations[player.id] = {
              t: 0,
              x: player.x,
              y: player.y,
              speed: INTERPOLATION_SPEED,
            };
          }
          interpolations[player.id].t = 0;
          const dx = (player.x - interpolations[player.id].x) ** 2;
          const dy = (player.y - interpolations[player.id].y) ** 2;
          if (Math.sqrt(dx + dy) > 5) {
            interpolations[player.id].t = 0.5;
          }
        }
      });

      socket.on("coins", (serverCoins) => {
        coins = serverCoins;
      });

      socket.on("playCoinSound", () => {
        coinAudio.currentTime = 0;
        coinAudio.play();
      });

      document.addEventListener("keydown", (e) => {
        controls[keyMap[e.key]] = true;
      });

      document.addEventListener("keyup", (e) => {
        controls[keyMap[e.key]] = false;
      });

      function update(delta) {
        socket.emit("controls", controls);

        for (let player of players) {
          const interpolation = interpolations[player.id];
          interpolation.x =
            interpolation.x * (1 - interpolation.t) +
            interpolation.t * player.x;
          interpolation.y =
            interpolation.y * (1 - interpolation.t) +
            interpolation.t * player.y;
          interpolation.t = Math.min(interpolation.t + interpolation.speed, 1);
        }
      }

      function getTileImageLocation(id) {
        if (!gameMap.tileset) return { x: 0, y: 0 };
        const cols = gameMap.tileset.width / TILE_SIZE;
        const rows = gameMap.tileset.height / TILE_SIZE;
        const x = ((id - 1) % cols) * TILE_SIZE;
        const y = parseInt((id - 1) / cols) * TILE_SIZE;
        return {
          x,
          y,
        };
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);

        let cx = 0;
        let cy = 0;

        const playerToFocus = players.find((player) => player.id === socket.id);
        if (playerToFocus) {
          cx = interpolations[playerToFocus.id].x - canvas.width / 2 + 140;
          cy = interpolations[playerToFocus.id].y - canvas.height / 2;
        }

        ctx.fillStyle = "#000000";
        for (let row = 0; row < map.length; row++) {
          for (let col = 0; col < map[row].length; col++) {
            const tileType = map[row][col];

            if (tileType !== 0) {
              const { x, y } = getTileImageLocation(tileType);
              ctx.drawImage(
                mapImage,
                x,
                y,
                TILE_SIZE,
                TILE_SIZE,
                col * TILE_SIZE - cx,
                row * TILE_SIZE - cy,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }

        for (const coin of coins) {
          ctx.fillStyle = "#FF00FF";
          ctx.fillRect(coin.x - cx, coin.y - cy, COIN_SIZE, COIN_SIZE);
        }

        for (let player of players) {
          const { x: px, y: py } = interpolations[player.id];

          if (player.id === socket.id) {
            ctx.fillStyle = "#ff0000";
            ctx.fillRect(
              px - 1 - cx,
              py - 1 - cy,
              PLAYER_SIZE + 2,
              PLAYER_SIZE + 2
            );
          }

          ctx.fillStyle = player.color;
          ctx.fillRect(px - cx, py - cy, PLAYER_SIZE, PLAYER_SIZE);
          ctx.fillStyle = "#000000";
          ctx.fillText(player.name, px - 10 - cx, py - 10 - cy);
        }
      }

      function loop(timestamp) {
        const delta = timestamp - lastRender;

        update(delta);
        draw();

        lastRender = timestamp;
        window.requestAnimationFrame(loop);
      }
      window.requestAnimationFrame(loop);
    </script>
  </body>
</html>
